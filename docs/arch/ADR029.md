# ADR029 - TITLE

- **Status**: Draft
- **Date**: 2025-02-25
- **Author**: Joshua Taylor MBCS

## Decision

<!-- 
    In a few sentences, describe the decision taken. 
-->

## Context

Since its inception, the family hubs services have been built with the
expectation of high user loads. For example, a previous SLA defined for the
'Find' service required it to support 1000 concurrent users. These SLAs were not
based on any current usage or projected adoption but were seemingly decided
top-down.

Due to this requirement, a microservices architecture style was adopted for the
family hubs services. This is defined as distributing the business logic of
family hubs into multiple independently hosted components
([ADR007](./ADR007-use-azure-app-services.md)), each with an exclusive
database([ADR002](./ADR002-use-a-managed-azure-database.md)). Then another layer
of independently hosted UI components would communicate with these services via
HTTP ([ADR001](./ADR001-use-http-for-inter-service-comms.md)) as needed to
retrieve data or process business transactions.

![](./img/ADR029-microservices.png)

The main justification for adopting this architectural style was its scalable
and elastic characteristics -- since if the system came under high user load,
each small component could quickly (due to their size) allocate new resources to
deal with the load.

As the family hubs services reached later stages of development and more of the
team turned over, the team found little evidence that large user loads would
appear. This caused the user load SLAs to be revised down to 50 concurrent users
on each of the services (are the team and stakeholders aligned on this?).

The team also found maintaining the microservices architecture quite arduous,
since any new feature would likely cut across multiple components and require
coordination between components. It also seemed quite wasteful in terms of
resource usage.

Given this revision and the ongoing struggles of the development team, it was
questioned whether the architecture style could be changed to reduce unnecessary
complexity and reduce the costs of changing the service.

## Options considered

<!-- 
    Briefly describe each option considered as a numbered list. Start with the selected option.
    It's usually wise to include a 'do nothing' option.

    e.g.

    1. (SELECTED) PostgreSQL
    2. Oracle
    3. SQL Server  
-->

## Consequences

### Option 1 - Single monolith with virtual hosts and a single database

- Would be the simplest possible architecture from a component stand-point,
  which would ease the process of making changes and improve developer
  experience.

- Could potentially improve overall service performance, since HTTP requests
  would be replaced with method calls.

- May be overall more reliable, since network faults would not interfere with
  message passing within the system.

- Would decrease the scalability of the services, since the entire monolith
  would need to scale together. Due to its size, this would take more resources
  compared to separate components at higher loads.

- When changes are made to the monolith, it may need to be regression tested in
  its entirety which would be a large task -- in opposition to just testing
  particular separate components.

- Since the entire monolith would be deployed together, this may lead to more
  overall downtime in the system -- for example a database migration might make
  the entire service unavailable instead of in just one component.

### Option 2 - Domain service consolidation

- Would be simpler than the current architecture which would improve its ability
  to change and improve the developer experience; though not to the extent as
  option 1.

- Would slightly decrease the scalability of the services, since the UI components 
  and domain components could each independently scale but not to the degree of
  option 3.

- Would slightly decrease testability, since a larger domain service would need
  to be regression tested whenever a domain change is made. However UI changes
  would not require a full service regression.

- Changes to the database requiring downtime would necessarily cause downtime in
  all services.

### Option 3 - Do nothing, retaining current microservices architecture

- Current issues with developer experience and complexity would remain -- likely
  slowing future development and testing efforts.

- Would scale better if the service started to experience high loads.

- Different domain areas would be explicitly decoupled, reducing the risk of
  business logic becoming entangled and affecting development costs.

- More fault tolerance is possible, since independently hosted components can
  also fail or error independently.

- Full regression testing of the services may be rarer than other options, since
  most development changes would only affect a minority of components.

- If transactions or data consistency are required in the future between
  services, this would be harder to facilitate.

## Advice

<!--
    List of advice gathered to make this decision, including the names and role of 
    advisors and the date each piece of advice was gathered.

    Before submitting a decision, you are expected to gather advice from all team 
    members or stakeholders who will be affected by the decision.
-->

- Aaron Yarborough, Lead developer (YYYY-MM-DD)

- Tina Gohil, Tester (YYYY-MM-DD)

- Dami Laleye, Tester (YYYY-MM-DD)

- A monolith would be a much better developer experience -- we would have more
  control, the system would be easier to think about and onboarding new
  developers would be much easier. Our team size is also not suited to
  microservices. (Zac King, Developer, 2025-02-26)

- Thomas Cheyney, Developer (YYYY-MM-DD)

- Stuart Maskell, Developer (YYYY-MM-DD)

- Paul Armstrong, DevOps Engineer (YYYY-MM-DD)
